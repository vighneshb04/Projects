"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoinbaseWalletProvider = void 0;
const error_1 = require("./core/error");
const serialize_1 = require("./core/error/serialize");
const interface_1 = require("./core/provider/interface");
const util_1 = require("./sign/util");
const provider_1 = require("./util/provider");
const Communicator_1 = require("./core/communicator/Communicator");
const ScopedLocalStorage_1 = require("./core/storage/ScopedLocalStorage");
const util_2 = require("./core/type/util");
class CoinbaseWalletProvider extends interface_1.ProviderEventEmitter {
    constructor(_a) {
        var { metadata } = _a, _b = _a.preference, { keysUrl } = _b, preference = __rest(_b, ["keysUrl"]);
        super();
        this.signer = null;
        this.isCoinbaseWallet = true;
        this.metadata = metadata;
        this.preference = preference;
        this.communicator = new Communicator_1.Communicator(keysUrl, metadata);
        const signerType = (0, util_1.loadSignerType)();
        if (signerType)
            this.signer = this.initSigner(signerType);
    }
    async request(args) {
        try {
            (0, provider_1.checkErrorForInvalidRequestArgs)(args);
            if (!this.signer) {
                switch (args.method) {
                    case 'eth_requestAccounts': {
                        const signerType = await this.requestSignerSelection(args);
                        const signer = this.initSigner(signerType);
                        await signer.handshake(args);
                        this.signer = signer;
                        (0, util_1.storeSignerType)(signerType);
                        break;
                    }
                    case 'net_version':
                        return 1; // default value
                    case 'eth_chainId':
                        return (0, util_2.hexStringFromNumber)(1); // default value
                    default: {
                        throw error_1.standardErrors.provider.unauthorized("Must call 'eth_requestAccounts' before other methods");
                    }
                }
            }
            return this.signer.request(args);
        }
        catch (error) {
            const { code } = error;
            if (code === error_1.standardErrorCodes.provider.unauthorized)
                this.disconnect();
            return Promise.reject((0, serialize_1.serializeError)(error));
        }
    }
    /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */
    async enable() {
        console.warn(`.enable() has been deprecated. Please use .request({ method: "eth_requestAccounts" }) instead.`);
        return await this.request({
            method: 'eth_requestAccounts',
        });
    }
    async disconnect() {
        var _a;
        await ((_a = this.signer) === null || _a === void 0 ? void 0 : _a.cleanup());
        this.signer = null;
        ScopedLocalStorage_1.ScopedLocalStorage.clearAll();
        this.emit('disconnect', error_1.standardErrors.provider.disconnected('User initiated disconnection'));
    }
    requestSignerSelection(handshakeRequest) {
        return (0, util_1.fetchSignerType)({
            communicator: this.communicator,
            preference: this.preference,
            metadata: this.metadata,
            handshakeRequest,
        });
    }
    initSigner(signerType) {
        return (0, util_1.createSigner)({
            signerType,
            metadata: this.metadata,
            communicator: this.communicator,
            callback: this.emit.bind(this),
        });
    }
}
exports.CoinbaseWalletProvider = CoinbaseWalletProvider;
