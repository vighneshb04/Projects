import { stringify } from "../../../utils/json.js";
import { nativeLocalStorage } from "../../../utils/storage/nativeStorage.js";
import { authEndpoint } from "../core/authentication/authEndpoint.js";
import { ClientScopedStorage } from "../core/authentication/client-scoped-storage.js";
import { guestAuthenticate } from "../core/authentication/guest.js";
import { customJwt } from "../core/authentication/jwt.js";
import { getLinkedProfilesInternal, linkAccount, } from "../core/authentication/linkAccount.js";
import { loginWithPasskey, registerPasskey, } from "../core/authentication/passkeys.js";
import { siweAuthenticate } from "../core/authentication/siwe.js";
import { EnclaveWallet } from "../core/wallet/enclave-wallet.js";
import { getUserStatus } from "../web/lib/actions/get-enclave-user-status.js";
import { sendOtp, verifyOtp } from "../web/lib/auth/otp.js";
import { deleteActiveAccount, socialAuth } from "./auth/native-auth.js";
import { logoutUser } from "./helpers/auth/logout.js";
import { ShardedWallet } from "./helpers/wallet/sharded-wallet.js";
export class InAppNativeConnector {
    constructor(options) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ecosystem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "passkeyDomain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "localStorage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "wallet", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = options.client;
        this.ecosystem = options.ecosystem;
        this.passkeyDomain = options.passkeyDomain;
        this.localStorage = new ClientScopedStorage({
            storage: nativeLocalStorage,
            clientId: this.client.clientId,
            ecosystemId: this.ecosystem?.id,
        });
    }
    async initializeWallet(authToken) {
        const storedAuthToken = await this.localStorage.getAuthCookie();
        if (!authToken && storedAuthToken === null) {
            throw new Error("No auth token provided and no stored auth token found to initialize the wallet");
        }
        const user = await getUserStatus({
            authToken: authToken || storedAuthToken,
            client: this.client,
            ecosystem: this.ecosystem,
        });
        if (!user) {
            throw new Error("Cannot initialize wallet, no user logged in");
        }
        const wallet = user.wallets[0];
        // TODO (enclaves): Migration to enclave wallet if sharded
        if (wallet && wallet.type === "enclave") {
            this.wallet = new EnclaveWallet({
                client: this.client,
                ecosystem: this.ecosystem,
                address: wallet.address,
                storage: this.localStorage,
            });
        }
        else {
            this.wallet = new ShardedWallet({
                client: this.client,
                storage: this.localStorage,
            });
        }
    }
    async getUser() {
        if (!this.wallet) {
            const localAuthToken = await this.localStorage.getAuthCookie();
            if (!localAuthToken) {
                return { status: "Logged Out" };
            }
            await this.initializeWallet(localAuthToken);
        }
        if (!this.wallet) {
            throw new Error("Wallet not initialized");
        }
        return this.wallet.getUserWalletStatus();
    }
    getAccount() {
        if (!this.wallet) {
            throw new Error("Wallet not initialized");
        }
        return this.wallet.getAccount();
    }
    preAuthenticate(args) {
        return sendOtp({
            ...args,
            client: this.client,
        });
    }
    async authenticate(params) {
        const strategy = params.strategy;
        switch (strategy) {
            case "email":
            case "phone": {
                return verifyOtp(params);
            }
            case "guest": {
                return guestAuthenticate({
                    client: this.client,
                    ecosystem: params.ecosystem,
                    storage: nativeLocalStorage,
                });
            }
            case "wallet": {
                return siweAuthenticate({
                    client: this.client,
                    wallet: params.wallet,
                    chain: params.chain,
                    ecosystem: params.ecosystem,
                });
            }
            case "google":
            case "facebook":
            case "discord":
            case "line":
            case "x":
            case "apple": {
                const ExpoLinking = require("expo-linking");
                const redirectUrl = params.redirectUrl || ExpoLinking.createURL("");
                return socialAuth({
                    auth: { strategy, redirectUrl },
                    client: this.client,
                    ecosystem: this.ecosystem,
                });
            }
            case "passkey":
                return this.passkeyAuth(params);
            case "jwt":
                return customJwt({
                    jwt: params.jwt,
                    client: this.client,
                    storage: this.localStorage,
                });
            case "auth_endpoint":
                return authEndpoint({
                    payload: params.payload,
                    client: this.client,
                    storage: this.localStorage,
                });
            default:
                throw new Error(`Unsupported authentication type: ${strategy}`);
        }
    }
    async connect(params) {
        const authResult = await this.authenticate({
            ...params,
            client: this.client,
            ecosystem: this.ecosystem,
        });
        await this.initializeWallet(authResult.storedToken.cookieString);
        if (!this.wallet) {
            throw new Error("Wallet not initialized");
        }
        const encryptionKey = params.strategy === "jwt"
            ? params.encryptionKey
            : params.strategy === "auth_endpoint"
                ? params.encryptionKey
                : undefined;
        await this.wallet.postWalletSetUp({
            ...authResult,
            encryptionKey,
        });
        const account = await this.getAccount();
        return {
            user: {
                status: "Logged In, Wallet Initialized",
                account,
                authDetails: authResult.storedToken.authDetails,
                walletAddress: account.address,
            },
        };
    }
    async passkeyAuth(args) {
        const { type, passkeyName, client, ecosystem, storeLastUsedPasskey = true, } = args;
        const domain = this.passkeyDomain;
        const storage = this.localStorage;
        if (!domain) {
            throw new Error("Passkey domain is required for native platforms. Please pass it in the 'auth' options when creating the inAppWallet().");
        }
        try {
            const { PasskeyNativeClient } = await import("./auth/passkeys.js");
            const passkeyClient = new PasskeyNativeClient();
            let authToken;
            if (type === "sign-up") {
                authToken = await registerPasskey({
                    client,
                    ecosystem,
                    username: passkeyName,
                    passkeyClient,
                    storage: storeLastUsedPasskey ? storage : undefined,
                    rp: {
                        id: domain,
                        name: domain,
                    },
                });
            }
            else {
                authToken = await loginWithPasskey({
                    client,
                    ecosystem,
                    passkeyClient,
                    storage: storeLastUsedPasskey ? storage : undefined,
                    rp: {
                        id: domain,
                        name: domain,
                    },
                });
            }
            return authToken;
        }
        catch (error) {
            console.error(`Error while signing in with passkey. ${error?.message || typeof error === "object" ? stringify(error) : error}`);
            if (error instanceof Error) {
                throw new Error(`Error signing in with passkey: ${error.message}`);
            }
            throw new Error("An unknown error occurred signing in with passkey");
        }
    }
    // TODO (rn) expose in the interface
    async deleteActiveAccount() {
        return deleteActiveAccount({
            client: this.client,
            storage: this.localStorage,
        });
    }
    logout() {
        return logoutUser({
            client: this.client,
            storage: this.localStorage,
        });
    }
    async linkProfile(args) {
        const { storedToken } = await this.authenticate(args);
        return await linkAccount({
            client: args.client,
            tokenToLink: storedToken.cookieString,
            storage: this.localStorage,
            ecosystem: args.ecosystem || this.ecosystem,
        });
    }
    async getProfiles() {
        return getLinkedProfilesInternal({
            client: this.client,
            ecosystem: this.ecosystem,
            storage: this.localStorage,
        });
    }
}
//# sourceMappingURL=native-connector.js.map