import { formatCompilerMetadata } from "../../contract/actions/compiler-metadata.js";
import { download } from "../../storage/download.js";
import { withCache } from "../promise/withCache.js";
import { isZkSyncChain } from "./zksync/isZkSyncChain.js";
/**
 * Fetches the deployment metadata.
 * @param options - The options for fetching the deploy metadata.
 * @returns An object containing the compiler metadata and extended metadata.
 * @internal
 */
export async function fetchDeployMetadata(options) {
    const rawMeta = await download({
        uri: options.uri,
        client: options.client,
    }).then((r) => r.json());
    const metadataUri = rawMeta.metadataUri;
    const parsedMeta = await fetchAndParseCompilerMetadata({
        client: options.client,
        uri: metadataUri,
    });
    return {
        ...rawMeta,
        ...parsedMeta,
        version: rawMeta.version,
        name: rawMeta.name,
    };
}
const CONTRACT_METADATA_TIMEOUT_SEC = 2 * 1000;
async function fetchAndParseCompilerMetadata(options) {
    // short timeout to avoid hanging on unpinned contract metadata CIDs
    const metadata = await (await download({
        ...options,
        requestTimeoutMs: CONTRACT_METADATA_TIMEOUT_SEC,
    })).json();
    if ((!metadata || !metadata.output) &&
        (!metadata.source_metadata || !metadata.source_metadata.output)) {
        throw new Error(`Could not resolve metadata for contract at ${options.uri}`);
    }
    return {
        ...metadata,
        ...formatCompilerMetadata(metadata),
    };
}
export async function fetchBytecodeFromCompilerMetadata(options) {
    const { compilerMetadata, client, chain } = options;
    return withCache(async () => {
        const isZksolc = await isZkSyncChain(chain);
        const bytecodeUri = isZksolc
            ? compilerMetadata.compilers?.zksolc?.[0]?.bytecodeUri
            : compilerMetadata.bytecodeUri;
        if (!bytecodeUri) {
            throw new Error(`No bytecode URI found in compiler metadata for ${compilerMetadata.name} on chain ${chain.name}`);
        }
        const deployBytecode = await download({
            uri: bytecodeUri,
            client,
        }).then((res) => res.text());
        return deployBytecode;
    }, {
        cacheKey: `bytecode:${compilerMetadata.name}:${chain.id}`,
        cacheTime: 24 * 60 * 60 * 1000,
    });
}
//# sourceMappingURL=deploy-metadata.js.map