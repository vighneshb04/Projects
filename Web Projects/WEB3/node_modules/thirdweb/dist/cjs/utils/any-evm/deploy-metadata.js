"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchDeployMetadata = fetchDeployMetadata;
exports.fetchBytecodeFromCompilerMetadata = fetchBytecodeFromCompilerMetadata;
const compiler_metadata_js_1 = require("../../contract/actions/compiler-metadata.js");
const download_js_1 = require("../../storage/download.js");
const withCache_js_1 = require("../promise/withCache.js");
const isZkSyncChain_js_1 = require("./zksync/isZkSyncChain.js");
/**
 * Fetches the deployment metadata.
 * @param options - The options for fetching the deploy metadata.
 * @returns An object containing the compiler metadata and extended metadata.
 * @internal
 */
async function fetchDeployMetadata(options) {
    const rawMeta = await (0, download_js_1.download)({
        uri: options.uri,
        client: options.client,
    }).then((r) => r.json());
    const metadataUri = rawMeta.metadataUri;
    const parsedMeta = await fetchAndParseCompilerMetadata({
        client: options.client,
        uri: metadataUri,
    });
    return {
        ...rawMeta,
        ...parsedMeta,
        version: rawMeta.version,
        name: rawMeta.name,
    };
}
const CONTRACT_METADATA_TIMEOUT_SEC = 2 * 1000;
async function fetchAndParseCompilerMetadata(options) {
    // short timeout to avoid hanging on unpinned contract metadata CIDs
    const metadata = await (await (0, download_js_1.download)({
        ...options,
        requestTimeoutMs: CONTRACT_METADATA_TIMEOUT_SEC,
    })).json();
    if ((!metadata || !metadata.output) &&
        (!metadata.source_metadata || !metadata.source_metadata.output)) {
        throw new Error(`Could not resolve metadata for contract at ${options.uri}`);
    }
    return {
        ...metadata,
        ...(0, compiler_metadata_js_1.formatCompilerMetadata)(metadata),
    };
}
async function fetchBytecodeFromCompilerMetadata(options) {
    const { compilerMetadata, client, chain } = options;
    return (0, withCache_js_1.withCache)(async () => {
        const isZksolc = await (0, isZkSyncChain_js_1.isZkSyncChain)(chain);
        const bytecodeUri = isZksolc
            ? compilerMetadata.compilers?.zksolc?.[0]?.bytecodeUri
            : compilerMetadata.bytecodeUri;
        if (!bytecodeUri) {
            throw new Error(`No bytecode URI found in compiler metadata for ${compilerMetadata.name} on chain ${chain.name}`);
        }
        const deployBytecode = await (0, download_js_1.download)({
            uri: bytecodeUri,
            client,
        }).then((res) => res.text());
        return deployBytecode;
    }, {
        cacheKey: `bytecode:${compilerMetadata.name}:${chain.id}`,
        cacheTime: 24 * 60 * 60 * 1000,
    });
}
//# sourceMappingURL=deploy-metadata.js.map