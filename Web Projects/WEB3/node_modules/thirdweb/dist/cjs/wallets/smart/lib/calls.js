"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.predictAddress = predictAddress;
exports.prepareCreateAccount = prepareCreateAccount;
exports.prepareExecute = prepareExecute;
exports.prepareBatchExecute = prepareBatchExecute;
const prepare_contract_call_js_1 = require("../../../transaction/prepare-contract-call.js");
const read_contract_js_1 = require("../../../transaction/read-contract.js");
const hex_js_1 = require("../../../utils/encoding/hex.js");
/**
 * Predict the address of a smart account.
 * @param args - The options for predicting the address of a smart account.
 * @returns The predicted address of the smart account.
 * @example
 * ```ts
 * import { predictAddress } from "thirdweb/wallets/smart";
 *
 * const predictedAddress = await predictAddress({
 *  factoryContract,
 *  adminAddress,
 *  accountSalt,
 * });
 * ```
 * @walletUtils
 */
async function predictAddress(args) {
    const { factoryContract, predictAddressOverride: predictAddress, adminAddress, accountSalt, accountAddress, } = args;
    if (predictAddress) {
        return predictAddress(factoryContract);
    }
    if (accountAddress) {
        return accountAddress;
    }
    if (!adminAddress) {
        throw new Error("Account address is required to predict the smart wallet address.");
    }
    const saltHex = accountSalt && (0, hex_js_1.isHex)(accountSalt)
        ? accountSalt
        : (0, hex_js_1.stringToHex)(accountSalt ?? "");
    return (0, read_contract_js_1.readContract)({
        contract: factoryContract,
        method: "function getAddress(address, bytes) returns (address)",
        params: [adminAddress, saltHex],
    });
}
/**
 * @internal
 */
function prepareCreateAccount(args) {
    const { adminAddress, factoryContract, createAccountOverride: createAccount, accountSalt, } = args;
    if (createAccount) {
        return createAccount(factoryContract);
    }
    const saltHex = accountSalt && (0, hex_js_1.isHex)(accountSalt)
        ? accountSalt
        : (0, hex_js_1.stringToHex)(accountSalt ?? "");
    return (0, prepare_contract_call_js_1.prepareContractCall)({
        contract: factoryContract,
        method: "function createAccount(address, bytes) returns (address)",
        params: [adminAddress, saltHex],
    });
}
/**
 * @internal
 */
function prepareExecute(args) {
    const { accountContract, transaction, executeOverride: execute } = args;
    if (execute) {
        return execute(accountContract, transaction);
    }
    return (0, prepare_contract_call_js_1.prepareContractCall)({
        contract: accountContract,
        method: "function execute(address, uint256, bytes)",
        params: [
            transaction.to || "",
            transaction.value || 0n,
            transaction.data || "0x",
        ],
        // if gas is specified for the inner tx, use that and add 21k for the execute call on the account contract
        // this avoids another estimateGas call when bundling the userOp
        // and also allows for passing custom gas limits for the inner tx
        gas: transaction.gas ? transaction.gas + 21000n : undefined,
    });
}
/**
 * @internal
 */
function prepareBatchExecute(args) {
    const { accountContract, transactions, executeBatchOverride: executeBatch, } = args;
    if (executeBatch) {
        return executeBatch(accountContract, transactions);
    }
    return (0, prepare_contract_call_js_1.prepareContractCall)({
        contract: accountContract,
        method: "function executeBatch(address[], uint256[], bytes[])",
        params: [
            transactions.map((tx) => tx.to || ""),
            transactions.map((tx) => tx.value || 0n),
            transactions.map((tx) => tx.data || "0x"),
        ],
    });
}
//# sourceMappingURL=calls.js.map