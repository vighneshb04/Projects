"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PACK_TOKEN_TYPE = void 0;
exports.createNewPack = createNewPack;
const contract_js_1 = require("../../contract/contract.js");
const upload_js_1 = require("../../storage/upload.js");
const units_js_1 = require("../../utils/units.js");
const createPack_js_1 = require("./__generated__/IPack/write/createPack.js");
var PACK_TOKEN_TYPE;
(function (PACK_TOKEN_TYPE) {
    PACK_TOKEN_TYPE[PACK_TOKEN_TYPE["ERC20"] = 0] = "ERC20";
    PACK_TOKEN_TYPE[PACK_TOKEN_TYPE["ERC721"] = 1] = "ERC721";
    PACK_TOKEN_TYPE[PACK_TOKEN_TYPE["ERC1155"] = 2] = "ERC1155";
})(PACK_TOKEN_TYPE || (exports.PACK_TOKEN_TYPE = PACK_TOKEN_TYPE = {}));
/**
 * @extension PACK
 * @example
 * ```ts
 * import { createNewPack } from "thirdweb/extensions/pack";
 *
 * const transaction = createNewPack({
 *   contract: packContract,
 *   client,
 *   recipient: "0x...",
 *   tokenOwner: "0x...",
 *   packMetadata: {
 *     name: "Pack #1",
 *     image: "image-of-pack-1",
 *   },
 *   openStartTimestamp: new Date(),
 *   erc20Rewards: [
 *     {
 *       contractAddress: "0x...",
 *       quantityPerReward: 1,
 *       totalRewards: 1,
 *     },
 *   ],
 *   erc721Rewards: [
 *     {
 *       contractAddress: "0x...",
 *       tokenId: 0n,
 *     },
 *   ],
 *   erc1155Rewards: [
 *     {
 *       contractAddress: "0x...",
 *       tokenId: 0n,
 *       quantityPerReward: 1,
 *       totalRewards: 1,
 *     },
 *   ],
 * });
 * ```
 */
function createNewPack(options) {
    return (0, createPack_js_1.createPack)({
        contract: options.contract,
        asyncParams: async () => getCreatePackParams(options),
    });
}
/**
 * @internal
 */
async function getCreatePackParams(options) {
    const { contract, recipient, packMetadata, amountDistributedPerOpen, openStartTimestamp, erc20Rewards, erc721Rewards, erc1155Rewards, tokenOwner, } = options;
    const [erc20Content, erc721Content, erc1155Content, packUri] = await Promise.all([
        processErc20Rewards({
            packContract: contract,
            content: erc20Rewards,
            tokenOwner,
        }),
        processErc721Rewards({
            packContract: contract,
            content: erc721Rewards,
            tokenOwner,
        }),
        processErc1155Rewards({
            packContract: contract,
            content: erc1155Rewards,
            tokenOwner,
        }),
        typeof packMetadata === "string"
            ? packMetadata
            : (0, upload_js_1.upload)({
                client: options.contract.client,
                files: [packMetadata],
            }),
    ]);
    const contents = erc20Content.content
        .concat(erc721Content.content)
        .concat(erc1155Content.content);
    const numOfRewardUnits = erc20Content.numOfRewardUnits
        .concat(erc721Content.numOfRewardUnits)
        .concat(erc1155Content.numOfRewardUnits);
    return {
        packUri,
        recipient,
        contents,
        numOfRewardUnits,
        // openStartTimestamp should be in seconds and not millisecond
        openStartTimestamp: BigInt(Math.ceil(openStartTimestamp.getTime() / 1000)),
        amountDistributedPerOpen,
    };
}
/**
 * @internal
 */
async function processErc20Rewards(options) {
    const { content, packContract, tokenOwner } = options;
    if (!content?.length) {
        return {
            content: [],
            numOfRewardUnits: [],
        };
    }
    const [{ allowance }, { decimals }] = await Promise.all([
        Promise.resolve().then(() => require("../erc20/__generated__/IERC20/read/allowance.js")),
        Promise.resolve().then(() => require("../erc20/__generated__/IERC20/read/decimals.js")),
    ]);
    const uniqueERC20Contracts = [
        ...new Set(content.map((o) => (0, contract_js_1.getContract)({
            address: o.contractAddress,
            chain: packContract.chain,
            client: packContract.client,
        }))),
    ];
    const data = (await Promise.all(uniqueERC20Contracts.map((contract) => {
        return Promise.all([
            allowance({
                contract,
                spender: packContract.address,
                owner: tokenOwner,
            }),
            decimals({ contract }).catch(() => undefined),
            contract.address,
        ]);
    }))).map((item) => {
        const [_allowance, _decimals, address] = item;
        if (_decimals === undefined) {
            throw new Error(`Failed to get the decimals of contract: ${address}. Make sure it is a valid ERC20 contract`);
        }
        return {
            _allowance,
            _decimals,
            address,
        };
    });
    const numOfRewardUnits = [];
    const result = content.map((item, index) => {
        const { contractAddress, quantityPerReward, totalRewards } = item;
        if (!totalRewards) {
            throw new Error(`Invalid totalRewards for contract: ${contractAddress} at index: ${index}`);
        }
        const _data = data.find((o) => o.address === contractAddress);
        if (!_data) {
            // This should never happen
            throw new Error(`contractAddress not found: ${contractAddress}`);
        }
        const quantityInWei = (0, units_js_1.toUnits)(String(quantityPerReward), _data._decimals);
        const totalRequired = quantityInWei * BigInt(totalRewards);
        if (totalRequired > _data._allowance) {
            throw new Error(`The following ERC20 contract address do not have enough allowance for the Pack contract: ${contractAddress}`);
        }
        numOfRewardUnits.push(BigInt(item.totalRewards));
        return {
            assetContract: contractAddress,
            tokenType: PACK_TOKEN_TYPE.ERC20,
            tokenId: 0n, // hard-coded to `0n` for ERC20
            totalAmount: totalRequired,
        };
    });
    return {
        content: result,
        numOfRewardUnits,
    };
}
/**
 * @internal
 */
async function processErc721Rewards(options) {
    const { content, packContract, tokenOwner } = options;
    if (!content?.length) {
        return {
            content: [],
            numOfRewardUnits: [],
        };
    }
    const uniqueERC721Contracts = [
        ...new Set(content.map((o) => ({
            contract: (0, contract_js_1.getContract)({
                address: o.contractAddress,
                chain: packContract.chain,
                client: packContract.client,
            }),
            tokenId: o.tokenId,
        }))),
    ];
    const [{ isApprovedForAll }, { getApproved }] = await Promise.all([
        Promise.resolve().then(() => require("../erc721/__generated__/IERC721A/read/isApprovedForAll.js")),
        Promise.resolve().then(() => require("../erc721/__generated__/IERC721A/read/getApproved.js")),
    ]);
    const numOfRewardUnits = [];
    const result = (await Promise.all(uniqueERC721Contracts.map(({ contract, tokenId }) => {
        return Promise.all([
            isApprovedForAll({
                contract,
                operator: packContract.address,
                owner: tokenOwner,
            }).catch(() => false),
            getApproved({ contract, tokenId }).catch(() => ""),
            contract.address,
            tokenId,
        ]);
    }))).map((item) => {
        const [_allApproved, _tokenApprove, address, tokenId] = item;
        if (!_allApproved &&
            _tokenApprove.toLowerCase() !== packContract.address.toLowerCase()) {
            throw new Error(`TokenID: ${tokenId} from contract address ${address} is not approved to be used by this Pack contract.`);
        }
        numOfRewardUnits.push(1n);
        return {
            assetContract: address,
            tokenType: PACK_TOKEN_TYPE.ERC721,
            tokenId,
            totalAmount: 1n,
        };
    });
    return {
        content: result,
        numOfRewardUnits,
    };
}
async function processErc1155Rewards(options) {
    const { content, packContract, tokenOwner } = options;
    if (!content?.length) {
        return {
            content: [],
            numOfRewardUnits: [],
        };
    }
    const uniqueERC1155Contracts = [
        ...new Set(content.map((o) => ({
            contract: (0, contract_js_1.getContract)({
                address: o.contractAddress,
                chain: packContract.chain,
                client: packContract.client,
            }),
            tokenId: o.tokenId,
            quantityPerReward: o.quantityPerReward,
            totalRewards: o.totalRewards,
        }))),
    ];
    const { isApprovedForAll } = await Promise.resolve().then(() => require("../erc1155/__generated__/IERC1155/read/isApprovedForAll.js"));
    const numOfRewardUnits = [];
    const result = (await Promise.all(uniqueERC1155Contracts.map(({ contract, tokenId, quantityPerReward, totalRewards }) => {
        return Promise.all([
            isApprovedForAll({
                contract,
                operator: packContract.address,
                owner: tokenOwner,
            }).catch(() => false),
            contract.address,
            tokenId,
            quantityPerReward,
            totalRewards,
        ]);
    }))).map((item) => {
        const [_allApproved, address, tokenId, quantityPerReward, totalRewards] = item;
        if (!_allApproved) {
            throw new Error(`ERC1155 contract address ${address} is not approved to be used by this Pack contract.`);
        }
        numOfRewardUnits.push(BigInt(totalRewards));
        return {
            assetContract: address,
            tokenType: PACK_TOKEN_TYPE.ERC1155,
            tokenId,
            totalAmount: BigInt(quantityPerReward) * BigInt(totalRewards),
        };
    });
    return {
        content: result,
        numOfRewardUnits,
    };
}
//# sourceMappingURL=createNewPack.js.map